import "TeamspeakQuery" from "../libs/ts3query.ptrs";
import "printf", "sprintf", "strcpy", "strstr", "strchr", "strlen", "sscanf", "qsort", "rand", "srand", "time";

var host = "127.0.0.1";
var user = "serveradmin";
var password = "hunter2";
var nick = "Munchkin";
var channel = 66;

var client = new TeamspeakQuery(host);
client.login(user, password, nick);
client.join(channel);

struct Card
{
	name;
	description;
	play; //(self, target, arg)
	event; //(id, self) //id 0 -> before play, id 1 -> on discard

	constructor(name, description, play, event = null)
	{
		this.name = name;
		this.description = description;
		this.play = play;
		this.event = event;
	}
};

struct Player
{
	tsId;
	tsNick[64];
	card;
	alive;
	protected;

	loose(killer, card)
	{
		var buff[256];

		if(this.protected)
		{
			sprintf(buff, "%s tried to kill %s using the %s but he is protected",
				killer.tsNick, this.tsNick, card.name, this.tsNick);
			broadcast(buff);
			return;
		}

		sprintf(buff, "%s is out because of %s's card %s. %s's handcard was %d.%s",
			this.tsNick, killer.tsNick, card.name, this.tsNick, this.card + 1, cardPrototypes[this.card].name);
		broadcast(buff);

		this.alive = false;

		var aliveCount = 0;
		var lastMan;
		for(var i = 0; i < playerCount; i++)
		{
			if(player[i].alive)
			{
				aliveCount++;
				lastMan = player[i];
			}
		}

		if(aliveCount == 1)
		{
			broadcast2("The game ended, the winner is %s", lastMan.tsNick);
			ingame = false;
		}
	}
};

var cardPrototypes = {
	new Card("Potted Plant", "Guess a players card, if you're right, hes out.", (self, target, arg) ->
	{
		if(arg <= 1 || arg > 8)
		{
			client.msgPriv(self.tsId, "Invalid argument, You have to guess the enemies card (number 2-8)");
			return false;
		}

		if(target.card == arg - 1)
		{
			target.loose(self, cardPrototypes[0]);
		}
		else
		{
			var buff[256];
			sprintf(buff, "%s played the 1.Potted Plant and guessed that %s has the card %d.%s but was wrong",
				self.tsNick, target.tsNick, arg, cardPrototypes[arg - 1].name);
			broadcast(buff);
		}
		return true;
	}),
	new Card("Maul Rat", "Look at a hand.", (self, target) ->
	{
		var buff[128];
		sprintf(buff, "%s's handcard is %d. %s", target.tsNick, target.card + 1, cardPrototypes[target.card].name);
		client.msgPriv(self.tsId, buff);
		broadcast2("%s spy'ed %s's card using a Maul Rat.", self.tsNick, target.tsNick);
		return true;
	}),
	new Card("Duck of Doom", "Compare two hands; Lower hand is out.", (self, target) ->
	{
		if(self.card < target.card)
			target.loose(self, cardPrototypes[2]);
		else if(self.card > target.card)
			target.loose(self, cardPrototypes[2]);
		else
			broadcast2("%s used Duck of Doom on %s but nothing happened", self.tsNick, target.tsNick);
		return true;
	}),
	new Card("Wishing Ring", "Protection until next turn", (self, target) ->
	{
		broadcast2("%s plays the 4.Wishing Ring on %s who is now protected until his next turn.", self.tsNick, target.tsNick);
		target.protected = true;
		return true;
	}),
	new Card("Net Troll", "One player discards his or her hand", (self, target) ->
	{
		var buff[256];
		sprintf(buff, "%s plays the Net Troll on %s. %s discards his card %s",
			self.tsNick, target.tsNick, target.tsNick, cardPrototypes[target.card].name);
		broadcast(buff);

		if(cardPrototypes[target.card].event != null)
			cardPrototypes[target.card].event(1, target);
		if(target.alive)
		{
			target.card = draw();
			if(ingame)
			{
				sprintf(buff, "Your new handcard is %d.%s", target.card + 1, cardPrototypes[target.card].name);
				client.msgPriv(target.tsId, buff);
			}
		}
		return true;
	}),
	new Card("Dread Gazebo", "Trade cards.", (self, target) ->
	{
		broadcast2("%s plays the 6.Dread Gazebo and trades card with %s", self.tsNick, target.tsNick);

		var tmp = target.card;
		target.card = self.card;
		self.card = tmp;

		var buff[128];
		sprintf(buff, "You got the %d.%s", self.card + 1, cardPrototypes[self.card].name);
		client.msgPriv(self.tsId, buff);
		sprintf(buff, "You got the %d.%s", target.card + 1, cardPrototypes[target.card].name);
		client.msgPriv(target.tsId, buff);
		return true;
	}),
	new Card("Turbonium Dragon", "Discard if with Dread Gazebo or Net Troll", (self) ->
	{
		broadcast2("%s plays the Turbonium Dragon", self.tsNick);
		return true;
	},
	(id, self, other) ->
	{
		if(id == 0 && (other == 6 || other == 5))
		{
			this.play(self);
			return true;
		}
	}),
	new Card("Loot!", "Loose if discarded", (self) ->
	{
		self.loose(self, cardPrototypes[7]);
		return true;
	},
	(id, self) ->
	{
		if(id == 1)
			self.loose(self, cardPrototypes[7]);
	})
};

function broadcast2(fmt, arg1, arg2)
{
	var buff[256];
	sprintf(buff, fmt, arg1, arg2);
	broadcast(buff);
}

function broadcast(msg)
{
	for(var i = 0; i < playerCount; i++)
	{
		client.msgPriv(player[i].tsId, msg);
	}
}

function draw()
{
	cardIndex++;

	if(cardIndex >= 16)
	{
		var max = -1;
		var winner;
		for(var i = 0; i < playerCount; i++)
		{
			if(player[i].alive && player[i].card > max)
			{
				max = player[i].card;
				winner = player[i];
			}
		}

		broadcast2("Out of cards. The winner is %s as he has the highest card %s",
			winner.tsNick, cardPrototypes[max].name);

		ingame = false;
		return;
	}

	return cards[cardIndex];
}

var playerCount = 0;
var player{6};
var ingame = false;

var cards = [0, 0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 6, 7];
var cardIndex = -1;

for(var i = 0; i < 6; i++)
{
	player[i] = new Player();
}

var sender[64];
var message[256];
while(true)
{
	var id = client.receive(message, sender);
	printf("%10.10s[%3d] : %s\n", sender, id, message);

	if(strstr(message, "!join") == message)
	{
		strcpy(player[playerCount].tsNick, sender);
		player[playerCount].tsId = id;
		playerCount++;

		if(playerCount == 6)
			ingame = true;

		broadcast2("Waiting for %d more players. Type !start to start now.", 6 - playerCount);
	}
	else if(playerCount > 0 && strstr(message, "!start") == message)
	{
		ingame = true;
	}

	if(ingame)
	{
		srand(time(NULL));
		qsort(cards, 16, 1, (a, b) -> rand() - 1073741824);
		qsort(player, playerCount, VARSIZE, (a, b) -> rand() - 1073741824);

		var welcomeMsg[512];
		strcpy(welcomeMsg, "Welcome to Munchkin Loot Letter. Players: ");
		for(var i = 0; i < playerCount; i++)
		{
			player[i].alive = true;
			var msg = welcomeMsg + strlen(welcomeMsg);
			sprintf(msg, "[%d]%s, ", player[i].tsId, player[i].tsNick);
		}

		for(var i = 0; i < playerCount; i++)
		{
			var card = draw();
			player[i].card = card;

			sprintf(message, "Your handcard: %d.%s", card + 1, cardPrototypes[card].name);
			client.msgPriv(player[i].tsId, welcomeMsg);
			client.msgPriv(player[i].tsId, message);
		}

		var turn = -1;
		var currPlayer;
		var card;

		function changeTurn()
		{
			var startTurn = turn;
			turn++;
			if(turn >= playerCount)
				turn = 0;

			while(!player[turn].alive)
			{
				turn++;
				if(turn >= playerCount)
					turn = 0;
			}

			currPlayer = player[turn];
			currPlayer.protected = false;

			sprintf(message, "It is now %s's turn.", player[turn].tsNick);
			for(var i = 0; i < playerCount; i++)
			{
				if(i != turn)
					client.msgPriv(player[i].tsId, message);
			}

			card = draw();
			if(!ingame)
				return;

			if(cardPrototypes[card].event != null)
			{
				if(cardPrototypes[card].event(0, currPlayer, currPlayer.card))
					return changeTurn();
			}
			if(cardPrototypes[currPlayer.card].event != null)
			{
				if(cardPrototypes[currPlayer.card].event(0, currPlayer, card))
					return changeTurn();
			}

			sprintf(message, "It's your turn. Do you want to play %d.%s or %d.%s",
				card + 1, cardPrototypes[card].name, currPlayer.card + 1, cardPrototypes[currPlayer.card].name);
			client.msgPriv(currPlayer.tsId, message);
		}
		changeTurn();

		while(ingame)
		{
			id = client.receive(message, sender);
			printf("%10.10s[%3d] : %s\n", sender, id, message);

			if(id == currPlayer.tsId && message[0] == 'p' && message[1] == ' ')
			{
				var len = strlen(message);
				var place = message[2] - '0' - 1;

				if(place != card && place != currPlayer.card)
				{
					var buff[256];
					sprintf(buff, "You dont have the card %d.%s", place + 1, cardPrototypes[place].name);
					client.msgPriv(currPlayer.tsId, buff);
					continue;
				}

				var _target = -1;
				var arg = -1;
				sscanf(message + 4, "%ld %ld", &_target, &arg);

				var target = -1;
				for(var i = 0; i < playerCount; i++)
				{
					if(player[i].tsId == _target)
					{
						target = i;
						break;
					}
				}

				var _hand = currPlayer.card;
				currPlayer.card = place == card ? currPlayer.card : card;

				if(place < 7 && (target < 0 || target > playerCount || !player[target].alive))
				{
					currPlayer.card = _hand;
					client.msgPriv(currPlayer.tsId, "Invalid target use your a id announced at the beginning of the game.");
				}
				else if(!player[target].alive)
				{
					currPlayer.card = _hand;
					client.msgPriv(currPlayer.tsId, "That targetted player is out of the game.");
				}
				else if(player[target].protected)
				{
					currPlayer.card = _hand;
					client.msgPriv(currPlayer.tsId, "That targetted player is protected.");
				}
				else if(!cardPrototypes[place].play(currPlayer, player[target], arg))
				{
					currPlayer.card = _hand;
				}
				else
				{
					broadcast("----------------------------------------------------------------------------------------------------------------");
					if(ingame)
						changeTurn();
				}
			}
			else if(strstr(message, "help") == message)
			{
				if(message[4] != 0 && message[5] > '0' && message[5] < '9')
				{
					var cardId = message[5] - '0' - 1;
					sprintf(message, "%d. %s : %s", cardId + 1, cardPrototypes[cardId].name, cardPrototypes[cardId].description);
					client.msgPriv(id, message);
				}
				else
				{
					client.msgPriv(id, "Get information about cards using help cardid. e.g. help 1");
					client.msgPriv(id, "Play a card using p cardid target argument e.g. p 0 2 to play your card [0] onto player [2]");
				}
			}
		}

		cardIndex = -1;
		playerCount = 0;
	}
}

while(true)
{


	if(id != client.ownId)
		client.msgPriv(id, message);
}
