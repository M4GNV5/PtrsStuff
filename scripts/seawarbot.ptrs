import "printf", "exit", "memset", "rand", "atoi", "usleep";
import "Socket", "SocketServer" from "../libs/network.ptrs";

var port = atoi(arguments[0]); //45119
var host = arguments[1];

var sock;
var timeout;
var width;
var height;
if(host == NULL)
{
	printf("Awaiting other player\n");
	var server = new SocketServer(port);
	sock = server.accept(500);
	width = 10;
	height = 10;
	timeout = 500;

	sock.sendc((timeout & 0xFF00) >> 8);
	sock.sendc(timeout & 0xFF);
	sock.sendc(width);
	sock.sendc(height);
	printf("Client connected with version: %d\n", sock.readc());
}
else
{
	printf("Connecting to %s:%d\n", host, port);
	sock = new Socket();
	sock.connect(host, port);
	timeout = (sock.readc() << 8) + sock.readc(); //for now we dont rly need this
	width = sock.readc();
	height = sock.readc();
	sock.sendc(42);
}

printf("Got settings:\n\ttimout: %d\n\tsize: %dx%d\n", timeout, width, height);

var waterSize = width * height;
var allyWater[waterSize];
memset(allyWater, 0, waterSize);

struct Ship
{
	length;
	fields{5};

	constructor(length)
	{
		this.length = length;
	}

	isSunk()
	{
		for(var i = 0; i < this.length; i++)
		{
			var val = allyWater[this.fields[i]] & 1;
			if(val == 0)
				return false;
		}
		return true;
	}
};

var ships = {
	new Ship(5),
	new Ship(4),
	new Ship(3),
	new Ship(2),
	null
};

for(var i = 0; ships[i] != null; i++)
{
	for(var j = 0; j < ships[i].length; j++)
	{
		var index = i * width + j;
		allyWater[index] = (i + 1) << 1;
		ships[i].fields[j] = index;
	}
}



function renderWater(water)
{
	for(var y = 0; y < height; y++)
	{
		printf("  ");
		for(var x = 0; x < width; x++)
		{
			var data = water[x * width + y];
			var shipId = (data >> 1) - 1;
			var hit = data & 1;

			if(shipId >= 0 && hit)
				printf("X");
			else if(shipId >= 0)
				printf("%1d", shipId & 0xff);
			else if(hit)
				printf("O");
			else
				printf(" ");
		}
		printf("\n");
	}

	for(var i = 0; i < 23 - height; i++)
	{
		printf("\n");
	}
}



var nextX = 0;
var nextY = 0;
function instaKillThemAll()
{
	while(true)
	{
		sock.sendc(nextX);
		sock.sendc(nextY);

		var resp = sock.readc();
		if(resp == 3)
		{
			printf("I won!\n");
			exit(0);
		}

		nextX++;
		if(nextX >= width)
		{
			nextX = 0;
			nextY++;
			if(nextY >= height)
			{
				printf("I should have won by now :(\n");
				exit(0);
			}
		}

		if(resp == 2)
		{
			var len = sock.readc();
			//printf("Sank ship of length %d at {", len);
			for(var i = 0; i < len; i++)
			{
				sock.readc(); sock.readc();
				/*printf("%d|%d", sock.readc(), sock.readc());
				if(i < len - 1)
					printf(", ");*/
			}
			//printf("}\n");
		}

		if(resp == 0)
		{
			handler = awaitWaterFromNub;
			return;
		}
	}
}

function awaitWaterFromNub()
{
	while(true)
	{
		var x = sock.readc();
		var y = sock.readc();
		var data = allyWater[x * width + y];
		allyWater[x * width + y] = data | 1;

		renderWater(allyWater);
		usleep(1000 * 500);

		if(data == 0)
		{
			sock.sendc(0);
			handler = instaKillThemAll;
			return;
		}
		else if(data & 1 == 1)
		{
			sock.disconnect();
			throw "Remote tried to shoot place %d|%d twice", x, y;
		}
		else
		{
			var ship = ships[(data >> 1) - 1];

			if(ship.isSunk())
			{
				for(var i = 0; ships[i] != null; i++)
				{
					if(i == data >> 1)
						continue;

					var sunk = ships[i].isSunk();
					if(!sunk)
					{
						break;
					}
					else if(sunk && ships[i + 1] == null)
					{
						sock.sendc(3);
						printf("The enemy won :(\n");
						exit(0);
					}
				}

				sock.sendc(2);
				sock.sendc(ship.length);
				for(var i = 0; i < ship.length; i++)
				{
					var index = ship.fields[i];
					sock.sendc(index / width);
					sock.sendc(index % width);
				}
			}
			else
			{
				sock.sendc(1);
			}
		}
	}
}

var handler = awaitWaterFromNub;
if(host == NULL)
	handler = instaKillThemAll;

try
{
	while(true)
	{
		handler();
	}
}
catch(e, s)
{
	renderWater(allyWater);

	printf("\n%s\n%s", e, s);
}
