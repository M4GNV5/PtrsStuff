import "malloc", "free", "strlen", "sprintf", "usleep";
import "SDLNet_ResolveHost", "SDLNet_TCP_GetPeerAddress", "SDLNet_TCP_Open", "SDLNet_TCP_Close",
 	"SDLNet_TCP_Send", "SDLNet_TCP_Recv", "SDL_GetError", "SDLNet_TCP_Accept",
	"SDLNet_AllocSocketSet", "SDLNet_FreeSocketSet", "SDLNet_AddSocket", "SDLNet_CheckSockets",
	"SDLNet_Read32", "SDLNet_Read16" from "libSDL_net-1.2.so.0";

struct Socket
{
	ip;
	socket;
	isServer;
	socketset;
	connected;
	constructor()
	{
		this.connected = false;
		this.socket = NULL;
		this.isServer = false;
		this.socketset = NULL;
	}

	connect(domain, port, createSet)
	{
		if(this.connected)
			throw "Already connected";

		this.ip = malloc(64);
		SDLNet_ResolveHost(this.ip, domain, port);

		this.socket = SDLNet_TCP_Open(this.ip);

		if(this.socket == NULL)
			throw (native)SDL_GetError() || "Could not connect to server";

		this.connected = true;

		if(createSet || typeidof createSet == undefined)
			this.createSet();
	}
	disconnect()
	{
		if(!this.connected)
			throw "Not connected";

		SDLNet_TCP_Close(this.socket);
		if(!this.isServer)
			free(this.ip);
		this.connected = false;

		if(this.socketset)
			SDLNet_FreeSocketSet(this.socketset);
	}

	getIp(buff, includePort)
	{
		if(!this.ip)
			throw "Not connected";

		var val = SDLNet_Read32(this.ip);

		if(buff)
		{
			var len = sprintf(buff, "%d.%d.%d.%d",
				val >> 24 & 0xff,
				val >> 16 & 0xff,
				val >> 8 & 0xff,
				val & 0xff);
			if(includePort)
				sprintf(buff + len, ":%d", this.getPort());
		}

		return val;
	}
	getPort()
	{
		return SDLNet_Read16(this.ip + 4);
	}

	createSet()
	{
		this.socketset = SDLNet_AllocSocketSet(1);
		if(this.socketset == NULL)
			throw (native)SDL_GetError() || "Could not create SocketSet";
		if(SDLNet_AddSocket(this.socketset, this.socket) == -1)
			throw (native)SDL_GetError() || "Could not create SocketSet";
	}
	available(timeout)
	{
		timeout = timeout || 0;
		var ready = SDLNet_CheckSockets(this.socketset, timeout);
		if(ready < 0)
			throw (native)SDL_GetError() || "Could not check availability";
		return ready > 0;
	}

	send(buff, len)
	{
		if(!this.connected)
			throw "Not connected";

		buff = buff || NULL;
		len = len || -1;

		var result = SDLNet_TCP_Send(this.socket, buff, len);
		if(result < len)
			throw (native)SDL_GetError() || "Unknown SDLNet error";
	}
	sends(str)
	{
		this.send(str, strlen(str));
	}
	sendc(val)
	{
		var buff[1];
		*buff = val;
		this.send(buff, 1);
	}

	recv(buff, len)
	{
		if(!this.connected)
			throw "Not connected";

		buff = buff || NULL;
		len = len || -1;

		var result = SDLNet_TCP_Recv(this.socket, buff, len);
		if(result <= 0)
			throw (native)SDL_GetError() || "Unknown SDLNet error";
	}
	read(buff, max, end)
	{
		var pos = 1;
		var err;
		var curr[1];

		this.recv(curr, 1);
		buff[0] = *curr;

		while(*curr != end && pos < max)
		{
			this.recv(curr, 1);
			buff[pos] = *curr;
			pos++;
		}
		return pos;
	}
	readAvailable(buff, max)
	{
		var pos = 0;
		var curr[1];
		while(this.available() && pos < max)
		{
			this.recv(curr, 1);
			buff[pos] = *curr;
			pos++;
		}
		return pos;
	}
};

struct SocketServer
{
	ip;
	socket;
	constructor(port)
	{
		this.ip = malloc(64);
		if(SDLNet_ResolveHost(this.ip, NULL, port) == -1)
			throw (native)SDL_GetError() || "Could not start listening";

		this.socket = SDLNet_TCP_Open(this.ip);

		if(this.socket == NULL)
			throw (native)SDL_GetError() || "Could not connect to server";
	}

	accept(checkInterval, createSet)
	{
		checkInterval = checkInterval || 0;
		while(true)
		{
			var rawSock = SDLNet_TCP_Accept(this.socket);
			if(rawSock != NULL)
			{
				var sock = new Socket();
				sock.socket = rawSock;
				sock.ip = SDLNet_TCP_GetPeerAddress(rawSock);
				sock.isServer = true;
				sock.connected = true;
				if(createSet || typeidof createSet == undefined)
					sock.createSet();
				return sock;
			}

			if(checkInterval > 0)
				usleep(checkInterval * 1000);
			else
				return undefined;
		}
	}

	close()
	{
		if(this.socket == NULL)
			throw "Attempting to close a not opened server";

		SDLNet_TCP_Close(this.socket);
		free(this.ip);
		free(this);
	}
};
