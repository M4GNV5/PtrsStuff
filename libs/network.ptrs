import "malloc", "free", "memset", "strlen", "usleep";
import "SDLNet_ResolveHost", "SDLNet_TCP_GetPeerAddress", "SDLNet_TCP_Open", "SDLNet_TCP_Close",
 	"SDLNet_TCP_Send", "SDLNet_TCP_Recv", "SDL_GetError", "SDLNet_TCP_Accept",
	"SDLNet_AllocSocketSet", "SDLNet_FreeSocketSet", "SDLNet_AddSocket", "SDLNet_CheckSockets" from "libSDL_net-1.2.so.0";

struct Socket
{
	ip;
	socket;
	isServer;
	socketset;
	connected;
	constructor()
	{
		this.connected = false;
		this.socket = NULL;
		this.isServer = false;
		this.socketset = NULL;
	}

	connect(domain, port, createSet)
	{
		if(this.connected)
			throw "Already connected";

		this.ip = malloc(64);
		SDLNet_ResolveHost(this.ip, domain, port);

		this.socket = SDLNet_TCP_Open(this.ip);

		if(this.socket == NULL)
			throw (string)SDL_GetError() || "Could not connect to server";

		this.connected = true;

		if(createSet || typeof createSet == "undefined")
			this.createSet();
	}
	disconnect()
	{
		if(!this.connected)
			throw "Not connected";

		SDLNet_TCP_Close(this.socket);
		if(!this.isServer)
			free(this.ip);
		this.connected = false;

		if(this.socketset)
			SDLNet_FreeSocketSet(this.socketset);
	}

	createSet()
	{
		this.socketset = SDLNet_AllocSocketSet(1);
		if(this.socketset == NULL)
			throw (string)SDL_GetError() || "Could not create SocketSet";
		if(SDLNet_AddSocket(this.socketset, this.socket) == -1)
			throw (string)SDL_GetError() || "Could not create SocketSet";
	}
	available(timeout)
	{
		timeout = timeout || 0;
		var ready = SDLNet_CheckSockets(this.socketset, timeout);
		if(ready < 0)
			throw (string)SDL_GetError() || "Could not check availability";
		return ready > 0;
	}

	send(buff, len)
	{
		if(!this.connected)
			throw "Not connected";

		buff = buff || NULL;
		len = len || -1;

		var result = SDLNet_TCP_Send(this.socket, buff, len);
		if(result < len)
			throw (string)SDL_GetError() || "Unknown SDLNet error";
	}
	sends(str)
	{
		this.send(str, strlen(str));
	}
	sendc(val)
	{
		var buff[1];
		memset(buff, val, 1);
		this.send(buff, 1);
	}

	recv(buff, len)
	{
		if(!this.connected)
			throw "Not connected";

		buff = buff || NULL;
		len = len || -1;

		var result = SDLNet_TCP_Recv(this.socket, buff, len);
		if(result <= 0)
			throw (string)SDL_GetError() || "Unknown SDLNet error";
	}
	read(buff, max, end)
	{
		var pos = 0;
		var err;
		var curr[1];
		memset(curr, 0, 1);

		while(*curr != end && pos < max)
		{
			this.recv(curr, 1);
			memset(buff + pos, *curr, 1);
			pos++;
		}
		return pos;
	}
};

struct SocketServer
{
	ip;
	socket;
	constructor(port)
	{
		this.ip = malloc(64);
		if(SDLNet_ResolveHost(this.ip, NULL, port) == -1)
			throw (string)SDL_GetError() || "Could not start listening";

		this.socket = SDLNet_TCP_Open(this.ip);

		if(this.socket == NULL)
			throw (string)SDL_GetError() || "Could not connect to server";
	}

	accept(checkInterval, createSet)
	{
		checkInterval = checkInterval || 0;
		while(true)
		{
			var rawSock = SDLNet_TCP_Accept(this.socket);
			if(rawSock != NULL)
			{
				var sock = new Socket();
				sock.socket = rawSock;
				sock.ip = SDLNet_TCP_GetPeerAddress(rawSock);
				sock.isServer = true;
				sock.connected = true;
				if(createSet || typeof createSet == "undefined")
					sock.createSet();
				return sock;
			}

			if(checkInterval > 0)
				usleep(checkInterval * 1000);
			else
				return undefined;
		}
	}

	close()
	{
		if(this.socket == NULL)
			throw "Attempting to close a not opened server";

		SDLNet_TCP_Close(this.socket);
		free(this.ip);
		free(this);
	}
};
