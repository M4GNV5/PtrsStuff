import sprintf, strncpy, strlen, malloc, strdup, free, strncmp, strtod;
import Map from "./map.ptrs";
import List from "./list.ptrs";

function json_encode(val)
{
	if(typeof val == type<undefined>)
	{
		return as<native>strdup("null");
	}
	else if(typeof val == type<int> || typeof val == type<float>)
	{
		return as<native>strdup(cast<native>val);
	}
	else if(typeof val == type<native>)
	{
		var len = strlen(val);
		var escapeCount = 0;
		for(var i = 0; i < len; i++)
		{
			if(val[i] < ' ' || val[i] > '~')
				escapeCount++;
		}

		var buff = as<native>malloc(3 + len + 5 * escapeCount);
		var buffptr = buff;
		*buffptr++ = '"';

		for(var i = 0; i < len; i++)
		{
			if(val[i] < ' ' || val[i] > '~')
				buffptr += sprintf(buffptr, "\\u00%hhX", val[i]);
			else
				*buffptr++ = val[i];
		}

		*buffptr++ = '"';
		*buffptr = 0;
		return as<native>strdup(buff);
	}
	else if(val instanceof List)
	{
		var array[val.length];
		val.toArray(array);
		return json_encode(array);
	}
	else if(typeof val == type<pointer> && sizeof val > 0)
	{
		var len = 1;
		var strings[sizeof val];
		for(var i = 0; i < sizeof val; i++)
		{
			strings[i] = json_encode(val[i]);
			len += strlen(strings[i]) + 1;
		}

		var buff = as<native>malloc(len);
		buff[0] = '[';
		var buffptr = buff + 1;

		for(var i = 0; i < sizeof val; i++)
		{
			buffptr += sprintf(buffptr, "%s,", strings[i]);
			free(strings[i]);
		}

		*buffptr-- = 0;
		*buffptr = ']';
		return buff;
	}
	else if(typeof val == type<struct>)
	{
		var count = 0;
		foreach(key in val)
			count++;

		var i = 0;
		var keyStrings[count];
		var valueStrings[count];
		var len = 2;

		foreach(key, value in val)
		{
			keyStrings[i] = json_encode(key);
			valueStrings[i] = json_encode(value);
			len += strlen(keyStrings[i]) + strlen(valueStrings[i]) + 2;
			i++;
		}

		var buff = as<native>malloc(len);
		buff[0] = '{';
		var buffptr = buff + 1;

		for(var i = 0; i < count; i++)
		{
			buffptr += sprintf(buffptr, "%s:%s,", keyStrings[i], valueStrings[i]);
			free(keyStrings[i]);
			free(valueStrings[i]);
		}

		*buffptr-- = 0;
		*buffptr = '}';
		return buff;
	}
	else
	{
		return json_encode(cast<native>val);
	}
}

function json_decode(str)
{
	var map = new Map();
	var parseArray;
	var parseObject;

	function skipSpaces()
	{
		while(*str == ' ' || *str == '\t' || *str == '\n')
			str++;
	}
	function parseString(buff, max)
	{
		if(*str++ != '"')
			throw "Invalid JSON, expected \" got %c" % *--str;

		var ptr = str;
		while(*str != '"')
			str++;

		var len = str - ptr;
		max = max || len;

		if(!buff)
			buff = as<native>malloc(len + 1);
		if(max < len)
			len = max - 1;

		strncpy(buff, ptr, len);
		buff[len] = 0;

		str++;
		return buff;
	}
	function parseValue()
	{
		if(*str == '{')
			return parseObject();
		if(*str == '[')
			return parseArray();
		if(*str == '"')
			return parseString();
		if(*str >= '0' && *str <= '9')
			return as<float>strtod(str, &str);

		if(strncmp(str, "null", 4) == 0)
		{
			str += 4;
			return undefined;
		}
		if(strncmp(str, "true", 4) == 0)
		{
			str += 4;
			return true;
		}
		if(strncmp(str, "false", 5) == 0)
		{
			str += 5;
			return false;
		}

		throw "Invalid JSON, expected value got %c" % *str;
	}
	function parseArray()
	{
		var list = new List();

		if(*str++ != '[')
			throw "Invalid JSON, expected [ got %c" % *--str;

		if(*str == ']')
		{
			str++;
			return list;
		}

		while(true)
		{
			skipSpaces();
			list.add(parseValue());
			skipSpaces();

			if(*str == ']')
				break;
			if(*str++ != ',')
				throw "Invalid JSON, expected , got %c" % *--str;
		}

		str++;
		return list;
	}
	function parseObject()
	{
		var map = new Map();

		if(*str++ != '{')
			throw "Invalid JSON, expected { got %c" % *--str;

		if(*str == '}')
		{
			str++;
			return map;
		}

		var key{32};
		while(true)
		{
			skipSpaces();
			parseString(key);
			skipSpaces();

			if(*str++ != ':')
				throw "Invalid JSON, expected : got %c" % *--str;

			skipSpaces();
			map[key] = parseValue();
			skipSpaces();



			if(*str == '}')
				break;
			if(*str++ != ',')
				throw "Invalid JSON, expected , got %c" % *--str;
		}
		str++;

		return map;
	}

	return parseValue();
}

function json_destroy(value)
{
	if(value instanceof Map)
	{
		foreach(key, val in value)
			json_destroy(val);

		delete value;
	}
	else if(value instanceof List)
	{
		foreach(val in value)
			json_destroy(val);

		delete value;
	}
	else if(typeof value == type<native>)
	{
		free(value);
	}
}
