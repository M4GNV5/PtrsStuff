import HTTP from "./curl.ptrs";
import List from "./list.ptrs";
import Map from "./map.ptrs";
import json_encode, json_decode, json_destroy from "./json.ptrs";
import strdup, free;

struct MessageUpdate
{
	id;
	chat;
	time;
	senderId;
	sender;
	text;

	constructor(data)
	{
		id = data.message_id;
		chat = data.chat.id;

		if("date" in data)
			time = data.date;
		else
			time = 0;

		senderId = data.from.id;
		sender = strdup!native(data.from.first_name);

		if("text" in data)
			text = strdup!native(data.text);
		else
			text = NULL;
	}
	destructor()
	{
		free(sender);
		if(text != NULL)
			free(text);
	}
};

struct CallbackQuery
{
	id;
	senderId;
	sender;
	message;
	action;

	private bot;

	constructor(data, _bot)
	{
		id = strdup!native(data.id);
		senderId = data.from.id;
		sender = strdup!native(data.from.first_name);

		message = new MessageUpdate(data.message);
		action = strdup!native(data.data);

		bot = _bot;
	}
	destructor()
	{
		delete message;
		free(id);
		free(sender);
		free(action);
	}

	answer(text, alert = false)
	{
		var req = new Map();
		req.callback_query_id = id;
		req.text = text;

		if(alert)
			req.alert = true;

		bot.makeRequest("answerCallbackQuery", req);
		delete req;
	}
};

struct InlineKeyboard
{
	inline_keyboard;

	constructor(rowCount = 1)
	{
		inline_keyboard = new List();
		this.addRow(rowCount);
	}

	destructor()
	{
		foreach(i, row in inline_keyboard)
		{
			foreach(j, elem in row)
			{
				delete elem;
			}
			delete row;
		}
		delete inline_keyboard;
	}

	addRow(count = 1)
	{
		for(var i = 0; i < count; i++)
			inline_keyboard.add(new List());
	}

	addButton(row = 0, text, action = text)
	{
		var elem = map {
			text: text,
			callback_data: action
		};
		inline_keyboard[row].add(elem);
	}
};

struct Telegram
{
	private token;
	offset = 0;
	constructor(_token)
	{
		token = _token;
	}

	makeRequest(path, data)
	{
		var url = "https://api.telegram.org/bot$token/$path";
		var resp;
		if(data)
		{
			if(typeof data != type<native>)
				data = json_encode(data);

			var reqHeader = map_stack {
				"Content-Type": "application/json"
			};
			resp = HTTP.POST(url, data, reqHeader);
		}
		else
		{
			resp = HTTP.GET(url);
		}

		var data = undefined;
		try
		{
			data = json_decode(resp.body);

			if(!data.ok)
				throw data.description;
		}
		finally
		{
			delete resp;
		}

		return data;
	}

	getUpdate()
	{
		var req = map_stack {
			limit: 1,
			timeout: 0x7FFFFFFF,
			allowed_updates: new_stack array[] ["message", "callback_query"],
			offset: offset
		};

		while(true)
		{
			req.offset = offset;
			var res = makeRequest("getUpdates", req);

			if(res.result.length == 0)
			{
				delete res;
				continue;
			}

			var update = res.result[0];
			offset = update.update_id + 1;

			if("message" in update && "text" in update.message)
			{
				var ret = new MessageUpdate(update.message);
				delete res;
				return ret;
			}
			else if("callback_query" in update)
			{
				var ret = new CallbackQuery(update.callback_query, this);
				delete res;
				return ret;
			}
			else
			{
				delete res;
			}
		}
	}

	sendMessage(chat, msg, markup)
	{
		var req;
		if(markup)
		{
			req = map_stack {
				chat_id: chat,
				text: msg,
				reply_markup: markup
			};
		}
		else
		{
			req = map_stack {
				chat_id: chat,
				text: msg
			};
		}

		var res = makeRequest("sendMessage", req);
		var id = res.result.message_id;
		json_destroy(res);
		return id;
	}
};
