import malloc, strncpy, memcpy, regcomp, regexec, regerror, regfree;

struct RegExp
{
	regex{64};

	constructor(str, ignoreCase = false, multiLine = false)
	{
		var flags = 1; //REG_EXTENDED
		if(ignoreCase)
			flags |= 2; //REG_ICASE
		if(multiLine)
			flags |= 4; //REG_NEWLINE

		var err = regcomp(this.regex, str, flags);
		if(err)
		{
			var buff[128];
			regerror(err, this.regex, buff, 128);
			throw buff;
		}
	}
	destructor()
	{
		regfree(this.regex);
	}

	test(str)
	{
		return regexec(this.regex, str, 0, NULL, 0) == 0;
	}

	match(str, maxMatches = 16)
	{
		var matches{8 * maxMatches};
		if(regexec(this.regex, str, maxMatches, matches, 0) != 0)
			return null;

		var starts[maxMatches];
		var lengths[maxMatches];

		var actualMatches = 1;
		var totalLen = VARSIZE;
		for(var i = 0; i < maxMatches; i++)
		{
			var start = 0;
			memcpy(&start, matches + 8 * i, 8);
			var end = start >> 32;
			start &= 0xffffffff;
			if(start < 0 || end < 0)
				break;

			actualMatches++;
			var len = end - start;
			starts[i] = start;
			lengths[i] = len;
			totalLen += VARSIZE + len + 1;
		}

		var buff = as<native>malloc(totalLen);
		var buffptr = as<pointer>buff;
		buff += actualMatches * VARSIZE;

		for(var i = 0; i < actualMatches - 1; i++)
		{
			buffptr[i] = buff;
			strncpy(buff, str + starts[i], lengths[i]);
			buff += lengths[i];
			*buff++ = 0;
		}
		buffptr[actualMatches - 1] = NULL;

		return buffptr;
	}
};
