import memcpy;
import pcre_compile, pcre_free, pcre_exec from "libpcre.so.3";

const PCRE_ERROR_NOMATCH = -1;

struct RegExp
{
	reg;

	constructor(pattern)
	{
		var err = NULL;
		var errOffset = 0;
		reg = pcre_compile!native(pattern, 0, &err, &errOffset, NULL);

		if(!reg)
			throw "PCRE: $err (index $errOffset)";
	}

	destructor()
	{
		pcre_free(reg);
	}

	test(str, offset = 0)
	{
		var count = pcre_exec!int(reg, NULL, str, sizeof str, offset, 0, NULL, 0);

		if(count < 0)
		{
			switch(count)
			{
				case PCRE_ERROR_NOMATCH:
					return false;
				default:
					throw "PCRE error $count";
			}
		}
		return true;
	}

	match(str, offset = 0, maxMatches = 16)
	{
		var matchOffsets{maxMatches * 8}; //TODO TypedArray
		var count = pcre_exec!int(reg, NULL, str, sizeof str, offset, 0, matchOffsets, maxMatches);

		if(count < 0)
		{
			switch(count)
			{
				case PCRE_ERROR_NOMATCH:
					return null;
				default:
					throw "PCRE error $count";
			}
		}

		var matches = new array[count];
		for(var i = 0; i < count; i++)
		{
			var start = 0;
			memcpy(&start, matchOffsets + i * 8, 8); //TODO TypedArray

			var stop = start >> 32;
			start &= 0xFFFFFFFF;

			matches[i] = str[start .. stop];
		}

		return matches;
	}
};
