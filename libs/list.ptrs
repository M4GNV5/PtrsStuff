import malloc, free;

struct ListEntry
{
	value;
	next;

	constructor(value, next = null)
	{
		this.value = value;
		this.next = next;
	}
};

struct List
{
	first = null;
	last = null;
	private _length = 0;

	destructor()
	{
		var curr = this.first;
		while(curr != null)
		{
			var prev = curr;
			curr = curr.next;
			delete prev;
		}
	}

	operator this[index]
	{
		var val = this.getEntry(cast<int>index);
		return &val.value;
	}
	operator sizeof this
	{
		return _length;
	}
	operator in this
	{
		var i = 0;
		var curr = this.first;
		while(curr != null)
		{
			var next = curr.next;
			if(yield curr.value, i++, &curr.value)
				return;
			curr = next;
		}
	}

	get length
	{
		return _length;
	}

	getEntry(index, previous = null)
	{
		var prev = null;
		var curr = this.first;
		var _index = index;
		while(curr != null && _index-- > 0)
		{
			prev = curr;
			curr = curr.next;
		}

		if(curr == null)
			throw "Index %d is not in list of length %d" % index, _length;

		if(previous != null)
			*previous = prev;
		return curr;
	}

	add(values...)
	{
		for(var i = 0; i < sizeof(values); i++)
		{
			var entry = new ListEntry(values[i]);

			if(this.last == null)
				this.first = entry;
			else
				this.last.next = entry;
			this.last = entry;
		}
		_length += sizeof(values);
	}

	remove(index)
	{
		var prev;
		var curr = this.getEntry(index, &prev);
		var val = curr.value;

		if(prev == null)
			this.first = curr.next;
		else
			prev.next = curr.next;

		if(this.first == null)
			this.last = null;

		_length--;
		delete curr;
		return val;
	}

	splice(index, deleteCount, insert...)
	{
		var prev;
		var curr = this.getEntry(index, &prev);

		for(var i = 0; i < deleteCount; i++)
		{
			var old = curr;
			curr = curr.next;
			delete old;
		}
		_length -= deleteCount;

		for(var i = 0; i < sizeof(insert); i++)
		{
			curr = new ListEntry(insert[i], curr);
		}
		_length += sizeof(insert);

		if(prev == null)
			this.first = curr;
		else
			prev.next = curr;
	}

	indexOf(value, start = 0, compare = (a, b) -> a == b)
	{
		var curr = this.getEntry(start);
		for(var i = 0; curr != null; i++)
		{
			if(compare(curr.value, value))
				return i;
			curr = curr.next;
		}
		return -1;
	}
	lastIndexOf(value, end, compare = (a, b) -> a == b)
	{
		var last = -1;
		var curr = this.first;
		for(var i = 0; curr != null; i++)
		{
			if(compare(curr.value, value, i))
				last = i;
			if(end && i >= end)
				break;
			curr = curr.next;
		}
		return last;
	}

	fromArray(buff, len = sizeof(buff))
	{
		var list = new List();
		var subset = buff[0 .. len];
		list.add(...subset);

		return list;
	}
	toArray(buff, max)
	{
		if(!max)
			max = buff ? sizeof buff : _length;
		if(!buff)
		{
			max = _length;
			buff = as<pointer>malloc(_length * VARSIZE);
		}

		var curr = this.first;
		for(var i = 0; curr != null && i < max; i++)
		{
			buff[i] = curr.value;
			curr = curr.next;
		}

		return buff;
	}
};
