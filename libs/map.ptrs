import strcmp, strncpy;

struct MapEntry
{
	key{32};
	value;
	next = null;

	constructor(key, value)
	{
		if(key)
			strncpy(this.key, cast<native>key, 31);
		this.key[31] = 0;
		this.value = value;
	}
};

struct Map
{
	first = null;
	length = 0;
	newEntry;

	constructor()
	{
		this.newEntry = new MapEntry();
	}
	destructor()
	{
		var curr = this.first;
		while(curr != null)
		{
			var _curr = curr;
			curr = curr.next;
			delete _curr;
		}

		delete this.newEntry;
	}

	operator this.key
	{
		return this.getValue(key);
	}
	operator this[key]
	{
		return this.getValue(key);
	}
	operator sizeof this
	{
		return this.length;
	}
	operator in this
	{
		this.appendNewEntry();
		var curr = this.first;
		while(curr != null)
		{
			if(yield curr.key, curr.value, &curr.value)
				return;
			curr = curr.next;
		}
	}

	appendNewEntry()
	{
		if(typeof this.newEntry.value != type<undefined>)
		{
			this.newEntry.next = this.first;
			this.first = this.newEntry;
			this.newEntry = new MapEntry();
		}
	}

	getEntry(key, previous = null)
	{
		this.appendNewEntry();

		key = cast<native>key;
		var prev = null;
		var curr = this.first;
		while(curr != null)
		{
			if(strcmp(key, curr.key) == 0)
			{
				if(previous != null)
					*previous = prev;
				return curr;
			}

			prev = curr;
			curr = curr.next;
		}

		if(previous != null)
			*previous = prev;
		return null;
	}

	has(key)
	{
		return !!this.getEntry(key);
	}

	getValue(key)
	{
		var entry = this.getEntry(key);
		if(entry != null)
		{
			return &entry.value;
		}
		else
		{
			strncpy(this.newEntry.key, cast<native>key, 31);
			this.newEntry.key[31] = 0;
			return &this.newEntry.value;
		}
	}

	remove(key)
	{
		var prev;
		var entry = this.getEntry(key, &prev);
		if(entry == null)
		{
			throw "Cannot remove non exisiting key '%s'" % key;
		}
		else
		{
			if(prev == null)
				this.first = entry.next;
			else
				prev.next = entry.next;

			this.length--;
			var val = entry.value;
			delete entry;
			return val;
		}
	}
};
