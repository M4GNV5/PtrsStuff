import strcmp, strncpy;

struct MapEntry
{
	key{32};
	value;
	next = null;

	constructor(key, value = null)
	{
		strncpy(this.key, cast<native>key, 31);
		this.key[31] = 0;
		this.value = value;
	}
};

struct Map
{
	first = null;
	length = 0;
	useThrow;

	constructor(useThrow = true)
	{
		this.useThrow = useThrow;
	}
	destructor()
	{
		var curr = this.first;
		while(curr != null)
		{
			var _curr = curr;
			curr = curr.next;
			delete _curr;
		}
	}

	operator this.key
	{
		return this.get(key);
	}
	operator this[key]
	{
		return this.get(key);
	}
	operator sizeof this
	{
		return this.length;
	}

	getEntry(key, previous = null)
	{
		key = cast<native>key;
		var prev = null;
		var curr = this.first;
		while(curr != null)
		{
			if(strcmp(key, curr.key) == 0)
			{
				if(previous != null)
					*previous = prev;
				return curr;
			}

			prev = curr;
			curr = curr.next;
		}

		if(previous != null)
			*previous = prev;
		return null;
	}

	has(key)
	{
		return !!this.getEntry(key);
	}

	get(key)
	{
		var entry = this.getEntry(key);
		if(entry != null)
			return entry.value;
		if(this.useThrow)
			throw "Cannot find key '%s'" % key;
	}

	set(key, val)
	{
		var prev;
		var entry = this.getEntry(key, &prev);

		if(entry != null)
		{
			entry.value = val;
		}
		else
		{
			entry = new MapEntry(key, val);
			if(prev == null)
				this.first = entry;
			else
				prev.next = entry;
			this.length++;
		}
	}

	remove(key)
	{
		var prev;
		var entry = this.getEntry(key, &prev);
		if(entry == null)
		{
			if(this.useThrow)
				throw "Cannot remove non exisiting key '%s'" % key;
			return;
		}
		else
		{
			if(prev == null)
				this.first = entry.next;
			else
				prev.next = entry.next;

			this.length--;
			var val = entry.value;
			delete entry;
			return val;
		}
	}
};
