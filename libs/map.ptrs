import strcmp, strncpy;

struct MapEntry
{
	key{32};
	value;
	next = null;

	constructor(key, value)
	{
		if(typeof key != type<undefined>)
			strncpy(this.key, cast<native>key, 31);
		this.key[31] = 0;
		this.value = value;
	}
};

struct Map
{
	private _length = 0;
	first = null;
	useThrow;

	get count
	{
		return _length;
	}

	constructor(useThrow = true)
	{
		this.useThrow = useThrow;
	}
	destructor()
	{
		var curr = this.first;
		while(curr != null)
		{
			var _curr = curr;
			curr = curr.next;
			delete _curr;
		}
	}

	private getEntry(key, previous = null)
	{
		key = cast<native>key;
		var prev = null;
		var curr = this.first;
		while(curr != null)
		{
			if(strcmp(key, curr.key) == 0)
			{
				if(previous != null)
					*previous = prev;
				return curr;
			}

			prev = curr;
			curr = curr.next;
		}

		if(previous != null)
			*previous = prev;
		return null;
	}

	getValue(key, getPtr = false)
	{
		var entry = getEntry(key);

		if(entry == null)
		{
			if(useThrow)
				throw "Trying to get key '$key' which is not in this map";
			return undefined;
		}

		return getPtr ? &entry.value : entry.value;
	}

	setValue(key, val)
	{
		var prev = null;
		var entry = getEntry(key, &prev);

		if(entry == null)
		{
			if(prev == null)
				this.first = new MapEntry(key, val);
			else
				prev.next = new MapEntry(key, val);

			_length++;
		}
		else
		{
			entry.value = val;
		}
	}

	hasValue(key)
	{
		return !!getEntry(key);
	}

	remove(key)
	{
		var prev;
		var entry = getEntry(key, &prev);
		if(entry == null)
		{
			if(useThrow)
				throw "Cannot remove non exisiting key '$key'";
			return undefined;
		}
		else
		{
			if(prev == null)
				this.first = entry.next;
			else
				prev.next = entry.next;

			_length--;
			var val = entry.value;
			delete entry;
			return val;
		}
	}

	operator this.key
	{
		return getValue(key);
	}
	operator this[key]
	{
		return getValue(key);
	}

	operator this.key = val
	{
		setValue(key, val);
	}
	operator this[key] = val
	{
		setValue(key, val);
	}

	operator &this.key
	{
		return getValue(key, true);
	}
	operator &this[key]
	{
		return getValue(key, true);
	}

	operator this.key(args...)
	{
		return getValue(key)(...args);
	}
	operator this[key](args...)
	{
		return getValue(key)(...args);
	}

	operator key in this
	{
		return !!getEntry(key);
	}
	operator sizeof this
	{
		return this._length;
	}
	operator foreach in this
	{
		var curr = this.first;
		while(curr != null)
		{
			if(yield curr.key, curr.value, &curr.value)
				return;
			curr = curr.next;
		}
	}
};
