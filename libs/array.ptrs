import ptrs_nativeTypes, ptrs_nativeTypeCount, strcmp, memcpy;

struct StructArray
{
	private array;
	private typ;
	private keepMem;
	private last = null;

	constructor(mem, _typ, keepMemory = false)
	{
		if(typeof mem == type<int>)
			mem = new array{mem * sizeof _typ};
		if(typeof mem != type<native>)
			throw "StructArray first argument must be of type native or int";

		array = mem;
		typ = _typ;
		keepMem = keepMemory;
	}

	destructor()
	{
		if(!keepMem && last != null)
			delete last;
	}

	operator this[index]
	{
		index = cast<int>index;
		if(index < 0 || index * sizeof typ > sizeof array)
			throw "Index $index is out of bounds of StructArray of size ${sizeof this}";

		if(!keepMem && last != null)
			delete last;

		last = cast<typ>(array + index * sizeof typ);
		return last;
	}
	operator &this[index]
	{
		index = cast<int>index;
		if(index < 0 || index * sizeof typ > sizeof array)
			throw "Index $index is out of bounds of StructArray of size ${sizeof this}";

		return array + index * sizeof typ;
	}

	operator index in this
	{
		return index * sizeof typ in array;
	}
	operator sizeof this
	{
		return sizeof array / sizeof typ;
	}

	operator foreach in this
	{
		var len = sizeof this;
		for(var i = 0; i < len; i++) scoped
		{
			var ptr = array + i * sizeof typ;
			var entry = cast_stack<typ>ptr;

			if(yield i, entry, ptr)
				return;
		}
	}
};

struct ptrs_nativetype_info
{
	name : native; //const char *
	size : size; //size_t
	getHandler : native; //ptrs_var_t *(*)(void *, size_t, ptrs_var_t *)
	setHandler : native; //ptrs_var_t *(*)(void *, size_t, ptrs_var_t *)
	ffiType : native; //void *
};
memcpy(&ptrs_nativeTypeCount, ptrs_nativeTypeCount, sizeof int); //TODO this only works for LE
ptrs_nativeTypeCount = as<int>ptrs_nativeTypeCount & 0xFFFFFFFF;
ptrs_nativeTypes = ptrs_nativeTypes[0 .. ptrs_nativeTypeCount * sizeof ptrs_nativetype_info];

struct TypedArray
{
	private static nativeTypes = null;
	private typ;
	private array;

	constructor(mem, typName)
	{
		if(!nativeTypes)
			nativeTypes = new StructArray(ptrs_nativeTypes, ptrs_nativetype_info, true);

		for(var i = 0; i < ptrs_nativeTypeCount; i++)
		{
			typ = nativeTypes[i];
			if(strcmp(typ.name, typName) == 0)
				break;

			delete typ;
			typ = null;
		}

		if(!typ)
			throw "Unknown type name '$typName'";

		if(typeof mem == type<int>)
			mem = new array{mem * typ.size};
		if(typeof mem != type<native>)
			throw "TypedArray first argument must be of type native or int";
		array = mem;
	}

	operator this[index]
	{
		index = cast<int>index;
		if(index < 0 || index * typ.size > sizeof array)
			throw "Index $index is out of bounds of TypedArray of size ${sizeof this}";

		var val;
		return *as<pointer>typ.getHandler(array + index * typ.size, typ.size, &val);
	}
	operator this[index] = val
	{
		index = cast<int>index;
		if(index < 0 || index * typ.size > sizeof array)
			throw "Index $index is out of bounds of TypedArray of size ${sizeof this}";

		typ.setHandler(array + index * typ.size, typ.size, &val);
	}
	operator &this[index]
	{
		index = cast<int>index;
		if(index < 0 || index * typ.size > sizeof array)
			throw "Index $index is out of bounds of TypedArray of size ${sizeof this}";

		return array + index * typ.size;
	}

	operator index in this
	{
		return index * typ.size in array;
	}
	operator sizeof this
	{
		return sizeof array / typ.size;
	}

	operator foreach in this
	{
		var len = sizeof this;
		for(var i = 0; i < len; i++) scoped
		{
			var ptr = array + i * typ.size;
			var valv;
			var val = *as<pointer>typ.getHandler(ptr, typ.size, &valv);

			if(yield i, val, ptr)
				return;
		}
	}
};
